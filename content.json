[{"title":"移植htop到ARM-Linux","date":"2017-03-21T11:00:00.000Z","path":"2017/03/21/htop_port_for_armlinux/","text":"在尝试了htop的好用之后果断抛弃了top命令。但是经常使用ARM-Linxu系统，在折腾了半天之后终于可以在ARM-Linux上愉快的使用htop了。 Ubuntu上使用htop与top相比，htop有以下优点： 可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。 在启动上，比top 更快。 杀进程时不需要输入进程号。 htop 支持鼠标操作。 top已经很老了。 htop 官网：http://hisham.hm/htop/。可以从官网下载离线安装包；Ubuntu在线安装命令如下： 12sudo apt-get updatesudo apt-get install htop 安装完成后输入htop命令即可，htop有功能键区使用起来非常简单方便。 移植htop到ARM-Linux OS : Ubuntu Server 14.04 Cross-Compile : arm-none-linux-gnueabi-gcc version 4.5.2 (Sourcery G++ Lite 2011.03-41) htop : htop-1.0.2.tar.gz ncurses : ncurses-5.9.tar.gz 之前编译htop时一直报错，不是这个： 12checking for curses.h... (cached) noconfigure: error: missing headers: curses.h curses.h 就是： 12checking for curses.h... (cached) noconfigure: error: missing libraries: libncurses 原本以为是ncurses的版本和htop的版本不兼容，可以使用网上教程一样的版本还是不行，换了其他好几个版本都不行。猜测可能是configure时使用的配置参数不太对。 以下为编译的步骤： 1、先下载htop-1.0.2.tar.gz和ncurses-5.9.tar.gz源码，放入同一文件夹下，然后使用tar -zxvf ./要解压的文件名分别进行解压。 2、编译ncurses，新建脚本文件cfg-ncurses.sh，内容如下： 12345678#!/bin/bash./configure --host=arm-none-linux-gnueabi --prefix=`pwd`/./install --enable-widec --without-sharedmake &amp;&amp; make installcd install/includeln -s ./ncursesw/curses.h curses.h 将其放入nucrses源码解压后的根目录下，然后添加可执行权限chmod +x ./cfg-ncurses.sh，执行即可。 3、编译htop，新建编译脚本文件cfg-htop.sh并写入内容如下： 12345#!/bin/bashac_cv_func_malloc_0_nonnull=yes ac_cv_func_realloc_0_nonnull=yes ac_cv_file__proc_stat=yes ac_cv_file__proc_meminfo=yes ./configure --host=arm-none-linux-gnueabi --enable-unicode LDFLAGS=-L../ncurses-5.9/install/lib CPPFLAGS=-I../ncurses-5.9/install/include --prefix=`pwd`/./installmake &amp;&amp; make install 同样放入htop源码根目录下，添加执行权限后执行。 4、将编译好的htop可执行文件(位于htop源文件夹下的install目录下)拷贝到ARM-Linux下的/usr/bin/文件夹下并赋予可执行权限。 5、拷贝刚才编译的ncurses文件夹下的install/share/terminfo/文件夹至ARM-Linux下的/usr/share/目录下。 6、终端下执行(建议写入启动配置文件省得每次开机重新配置)： 12export TERMINFO=/usr/share/terminfoexport TERM=xterm 然后执行htop即可看到界面： 其他： 若执行htop时出现如下错误提示： 123&gt; ~ # htop &gt; Error opening terminal: xterm.&gt; 检查/usr/share/terminfo/目录下的名为X的目录，若名称为大写的X，则将其改成小写的x即可。 在嵌入式Linux使用htop时发现有部分功能键不能用，但是鼠标点击可以使用。可能是使用的模拟终端兼容性不好，或者是移动到ARM-Linux上有些bug。待后面再测试下。 -—————————————–博客地址 : liuzhiqiang.tech","tags":[{"name":"Software Port","slug":"Software-Port","permalink":"http://yoursite.com/tags/Software-Port/"}]},{"title":"SQL必知必会(下)-插入、更新与事务","date":"2017-03-09T07:00:00.000Z","path":"2017/03/09/sql_must_know_will_be_3th/","text":"SQL必知必会(上) 主要是查询语句SELECT相关的使用，接下来进行增、删、改的学习。 数据插入1234--方式一INSERT INTO tablename VALUES(val1,val2,...)--方式二INSERT INTO tablename(column1,column2,...) VALUES(val1,val2,...) 方式一中，VALUES的值必须按照表定义中出现的次序填充每个列的值，没有列值的应当填NULL； 方式二中，提供了列名(可以是全部或者部分)，VALUES必须以其指定的次序匹配指定的列名，不一定按各列出现在表中的实际次序。省略列时应注意如下： 该列定义为允许NULL值（无值或空值）。 在表定义中给出默认值。这表示如果不给出值，将使用默认值。 插入检索出的数据 1INSERT INTO tablename1(column1,column2,...) SELECT column1,column2,... FROM tablename2 上述操作会插入所有被筛选出来的值。但是要注意tablename2表中的主键值不能和tablename1中的主键值相同，否者后续的INSERT会插入失败。 不一定要求列名匹配。事实上，DBMS一点儿也不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一列，第二列将用来填充表列中指定的第二列，如此等等。 从一个表复制到另一个表 123SELECT * INTO CustCopy FROM Customers;--不同数据的语法稍有不同，下面语句在SQLite中测试通过CREATE TABLE CustCopy AS SELECT * FROM Customers; 要将一个表的内容复制到一个全新的表（运行中创建的表），可以使用SELECT INTO语句。 可以复制全部或者部分列，只需将通配符*改成相应列名即可。 任何SELECT选项和子句都可以使用，包括WHERE和GROUP BY； 可利用联结从多个表插入数据； 不管从多少个表中检索数据，数据都只能插入到一个表中。 更新和删除数据更新数据1234UPDATE CustomersSET cust_contact = 'Sam Roberts', cust_email = 'sam@toyland.com'WHERE cust_id = '1000000006' UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。 要删除某个列的值，可设置它为NULL（假如表定义允许NULL值） 删除数据1DELETE FROM tablename WHERE condition 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，而速度更快（因为不记录数据的变动）。（SQLite3不支持，可以使用DROP TABLE来删除重建） 创建和操纵表创建表 12345678CREATE TABLE Products( prod_id INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000) NULL); NULL值是没有值，不是空字符串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空字符串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空字符串指定。 SQL允许指定默认值，在插入行时如果不给出值，DBMS将自动采用默认值。默认值在CREATE TABLE语句的列定义中用关键字DEFAULT指定。 更新表 增加列 1ALTER TABLE Vendors ADD vend_phone CHAR(20); 删除列（SQLite3不支持） 1ALTER TABLE Vendors DROP COLUMN vend_phone CHAR(20); SQLite对使用ALTER TABLE执行的操作有所限制。最重要的一个限制是，它不支持使用ALTER TABLE定义主键和外键，这些必须在最初创建表时指定。 删除表 1DROP TABLE Vendors; 重命名表（SQLite3测试支持） 1ALTER TABLE oldname RENAME TO newname 视图 SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。 视图：为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据。一些常见应用： 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。 创建视图 123456789101112131415--利用视图简化复杂的联结CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num;--用视图重新格式化检索出的数据CREATE VIEW VendorLocations ASSELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')'AS vend_titleFROM Vendors;--用视图过滤不想要的数据--使用视图与计算字段 视图重命名 删除视图，可以使用DROP语句，其语法为DROP VIEW viewname;。覆盖（或更新）视图，必须先删除它，然后再重新创建。 事务使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。 几个术语： 事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），可以对它发布回退（与回退整个事务处理不同）。 可以回退哪些语句？事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句（回退SELECT语句也没有必要），也不能回退CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退时，这些操作也不撤销。 SQLite3支持的语句：123BEGIN TRANSACTION 或者 BEGIN --开始事务COMMIT 或者 END TRANSACTION --提交事务ROLLBACK --回滚操作 存储过程和游标SQLite3不支持存储过程和游标。 约束作为主键（PRIMARY KEY）的条件 任意两行的主键值都不相同。 每行都具有一个主键值（即列中不允许NULL值）。 包含主键值的列从不修改或更新。（大多数DBMS不允许这么做，但如果你使用的DBMS允许这样做，好吧，千万别！） 主键值不能重用。如果从表中删除某一行，其主键值不分配给新行。 外键（REFERENCES） 外键是表中的一列，其值必须列在另一表的主键中。外键是保证引用完整性的极其重要部分（外键有助防止意外删除）。 SQLite3用法（定义字段时使用）： 1FOREIGN KEY(columnname) REFERENCES tablename(column1) 在SQLite中启用外键支持 1)为了在SQLite中使用外键约束, 编译sqlite库时, 不能使用 忽略 外键和触发器, 也就是 SQLITE_OMIT_FOREIGN_KEY 和 SQLITE_OMIT_TRIGGER不能被定义 2)必须在运行时打开, 因为 默认是关闭的 PRAGMA foreign_keys = ON; 编程时：sqlite3_exec(ppDb, “PRAGMA foreign_keys = ON;”, 0, 0, 0); 其他写法：123ALTER TABLE OrdersADD CONSTRAINTFOREIGN KEY (cust_id) REFERENCES Customers (cust_id) 唯一约束（UNIQUE） 唯一约束用来保证一列（或一组列）中的数据是唯一的。它们类似于主键，但存在以下重要区别。 表可包含多个唯一约束，但每个表只允许一个主键。 唯一约束列可包含NULL值。 唯一约束列可修改或更新。 唯一约束列的值可重复使用。 与主键不一样，唯一约束不能用来定义外键。 检测约束 12插入字段时： quantity INTEGER NOT NULL CHECK (quantity &gt; 0)ALTER TABLE检查名为gender的列只包含M或F：ADD CONSTRAINT CHECK (gender LIKE '[MF]') 索引 1CREATE INDEX prod_name_ind ON PRODUCTS (prod_name); 索引必须唯一命名。这里的索引名prod_name_ind在关键字CREATE INDEX之后定义。ON用来指定被索引的表，而索引中包含的列（此例中仅有一列）在表名后的圆括号中给出。 触发器 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_nameBEGIN -- Trigger logic goes here....END; 在这里，event_name 可以是在所提到的表 table_name 上的 INSERT、DELETE 和 UPDATE 数据库操作。您可以在表名后选择指定 FOR EACH ROW。 以下是在 UPDATE 操作上在表的一个或多个指定列上创建触发器（Trigger）的语法： 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name ON table_nameBEGIN -- Trigger logic goes here....END; 参考[1] SQLite支持的SQL语句：http://www.sqlite.org/lang.html [2] SQLite3菜鸟教程：http://www.runoob.com/sqlite/sqlite-tutorial.html -——————————博客地址 : liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"SQL必知必会(中)-子查询、组合查询与连结","date":"2017-03-02T10:00:00.000Z","path":"2017/03/02/sql_must_know_will_be_2nd/","text":"接上篇《SQL必知必会(上)-查询、计算与分组》 子查询123SELECT [column1,column2,...] FROM tablename WHERE condition [AND | OR] columnone [NOT]IN (SELECT columnone FROM tablename2 WHERE ... IN (SELECT...)) 使用子查询应该注意的地方： 子查询的嵌套的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。 作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。 作为计算字段使用子查询123456789--需要查询Customers表中每个顾客的订单总数。订单与相应的顾客ID存储在Orders表中--完全限定列名：用一个句点分隔表名和列名，这种语法必须在有可能混淆列名时使用，此处是2个表的cust_id比较SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS ordersFROM Customers ORDER BY cust_name; 联结表 创建联结 在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中没有指示DBMS如何对表进行联结的内容。 1234--prod_name和prod_price在一个表中，而vend_name在另一个表中。SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 注意：没有WHERE子句，第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起。 目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）。其实，可以对这种联结使用稍微不同的语法，明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据： 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN ProductsON Vendors.vend_id = Products.vend_id; 笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 叉联结（cross join）有时，返回笛卡儿积的联结，也称叉联结。 子查询和联接： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01')); 等效于： 12345SELECT cust_name, cust_contactFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = 'RGAN01'; 创建高级联结 迄今为止，我们使用的只是 内联结 或 等值联结 的简单联结。现在来看三种其他联结：自联结（self-join）、自然联结（natural join）和外联结（outer join）。 sqlite3 定义了三种主要类型的连接： 交叉连接 - CROSS JOIN （笛卡尔积 x*y） 内连接 - INNER JOIN (默认是内连接, inner 可以省略, 左右表都满足条件才显示) 外连接 - OUTER JOIN (sqlite3只支持 Left连接， 用右表来匹配左表，即每一行先从左表拿一条数据，再去右表找，右表没有找到，右表的项显示空，但是左表还是会显示) 自联结（self-join） 123456789101112-- 子查询写法SELECT cust_id, cust_name, cust_contactFROM CustomersWHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones');-- 自联结（self-join）SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones';--此查询中需要的两个表实际上是相同的表，为了解决Customers的引用歧义性，使用表别名。Customers第一次出现用了别名C1，第二次出现用了别名C2。 需要注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。 自然联结（natural join） 无论何时对表进行联结，应该至少有一列不止出现在一个表中（被联结的列）。标准的联结（内联结）返回所有数据，相同的列甚至多次出现。自然联结排除多次出现，使每一列只返回一次。 自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成。 123456SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01'; 外联结（outer join） 1SELECT * FROM table1 [left | right | full] OUTER JOIN table2 ON conditional 全外联结（full outer join），它检索两个表中的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表的不关联的行不同，全外联结包含两个表的不关联的行。 组合查询SQL允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union） 或 复合查询（compound query）。 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据。 123SELECT [] FROM tablename1 WHERE conditional1UNION SELECT [] FROM tablename2 WHERE conditional2 UNION使用的规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。 其他说明 UNION从查询结果集中自动去除了重复的行；如果想返回所有的匹配行，可使用UNION ALL而不是UNION。 在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后。 其他类型的UNION，某些DBMS还支持另外两种UNION：EXCEPT（有时称为MINUS）可用来检索只在第一个表中存在而在第二个表中不存在的行；而INTERSECT可用来检索两个表中都存在的行。 ——————————博客地址：liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"SQL必知必会(上)-查询、计算与分组","date":"2017-03-01T12:00:00.000Z","path":"2017/03/01/sql_must_know_will_be_1st/","text":"最近这段时间做了一个公司的项目，用到 SQLite3 数据库来存储数据，虽然数据并发要求不高，但存储数据量活动量有几十万（动态增删）。而且要保证机器全年正常运行。项目的有些部分数据操作实现是在应用程序部分实现，但是用 SQL 来内部实现的话效率会更高同时代码也更简洁。所以趁最近空闲一些来读下《SQL 必知必会》来补充一下欠缺。 SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写 主键（primary key）主键的作用：便于数据库的操作和管理，没有主键，更新或删除特定行就会比较困难。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。 当多个列作为主键时，上述条件必须应用到所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。 SELECT语句12SELECT [DISTINCT] [column1,column2,...] [*] FROM table WHERE [关系逻辑条件] [通配符搜索 LIKE] [限制 LIMIT] [子查询] [排序 ORDER BY] ... 不是必须的情况下，尽量少使用通配符；检索不需要的列通常会降低检索和程序性能。 DISTINCT去除字段值相同的列SELECT DISTINCT column FROM … 指定从哪儿开始以及检索的行数：LIMIT num OFFSET offset_row 从 offset_row行开始检索num行（第一个被检索的行是第0行）。简化版写法：LIMIT offset_row,num （不同数据库写法有区别，此写法可用于SQLite3） 在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。DESC降序，DESC关键字只应用到直接位于其前面的列名，如果想在多个列上进行降序排序，必须对每一列指定DESC关键字。升序排列（默认）ASC。 组合WHERE子句： 逻辑操作符AND，OR（其中AND的优先级大于OR）； IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配（类似于OR）。IN取一组由逗号分隔、括在圆括号中的合法值； NOT操作符（组合其他操作符使用，否定条件）。 通配符（wildcard）：通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索。 %表示任何字符出现任意次数（0个、1个或多个，不匹配NULL）； 下划线（_），匹配单个字符。 方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。只有微软的Access和SQL Server支持集合。 说明：通配符搜索耗时，应减少使用。同时应尽量不要把它们用在搜索模式的开始处。 注释： 使用– （两个连字符）嵌在行内，– 之后的文本就是注释； 多行注释： /* 注释内容 */ ； 单行注释： #注释内容（SQLite3不支持这种注释方式）。 WHERE子句操作符（不是所有DBMS都适用） 操作符 说 明 = 等于 &lt; &gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 ! 不小于 &gt; 大于 &gt;= 大于等于 !&gt; 不大于 BETWEEN … AND … 在指定的两个值之间 IS NULL 为NULL值 计算字段拼接字段：将值联结到一起（将一个值附加到另一个值）构成单个值。Access和SQL Server使用+号。DB2、Oracle、PostgreSQL、SQLite和Open Office Base使用 || 。 1SELECT vend_name + ' (' + vend_country + ')' FROM Vendors ORDER BY vend_name; 若某个字段有空白字符，可以使用函数去除：前导空白 (LTrim)、尾随空白 (RTrim) 或前导和尾随空白 (Trim)。 对于拼接字段后新列的名字，可以使用别名（alias），用AS关键字赋予。别名还有其他用途。常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 1SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')' AS vend_title FROM Vendors ORDER BY vend_name; 算术计算 直接计算使用方式： 1SELECT id,No,id*No AS new_name FROM tablename WHERE ... SQL算术操作符 操 作 符 说 明 + 加 - 减 * 乘 / 除 数值处理函数，字符串处理函数，时间日期处理函数 … SQL聚集函数：（aggregate function） 对某些行运行的函数，计算并返回一个值。 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG()函数只能作用于单个列，且计算式忽略列值为NULL的行。 COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 SUM()、MAX()和MIN()函数同样忽略列值为NULL的行。 以上5个聚合函数均可如下使用： 对所有行执行计算，指定ALL参数或不指定参数（因为ALL是默认行为）。 只包含不同的值，指定DISTINCT参数。 分组数据12SELECT [column,聚合] FROM TableWHERE ... GROUP BY (分组column) HAVING ... ORDER BY ... GROUP BY 的一些规定： GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）。 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组： HAVING支持所有WHERE操作符。 HAVING 和 WHERE 的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤。 分组和排序 ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 SELECT子句顺序 子 句 说 明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 -———————–博客地址 : liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"修复sqlite3数据库","date":"2017-02-28T02:00:00.000Z","path":"2017/02/28/repair_sqlite3_db/","text":"最近碰到几次SQLite3数据库损坏的情况。现象是使用SQLite3可视化工具打开时出现密码输入框，可是SQLite3数据库在开发的时候根本没有添加加密模块，猜测可能是数据库被损坏了。因数据库里都是现场数据，需要取出分析，只能Google资料尝试恢复。 确定问题将数据库放入程序中，执行SQL操作的时候发现数据库有报错。 1malformed database schema (0)(ErrCode:11) 对于ErrCode:11。在官网可以查询到起具体含义，以及产生这种错误的可能原因： (11) SQLITE_CORRUPT The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the How To Corrupt Your Database Files for further discussion on how corruption can occur. 结合我们的实际情况猜测，机器应该是在数据库正在写入的时候突然断电或主程序被Kill导致数据写入不完整而被损坏了。 在命令行工具下，执行PRAGMA integrity_check 命令可以检测数据库完整性。 解决方法在官方提供的命令行工具下，将数据库导出为sql文件，然后新建数据库导入即可。 导出sql文件 $sqlite3 Test.db $sqlite&gt;.output tmp.sql $sqlite&gt;.dump $sqlite&gt;.quit 再导入到一个数据库中 $sqlite3 New.db $sqlite&gt;.read tmp.sql $sqlite&gt;.quit 自此，数据库已恢复完成，可以用可视化工具打开了！ 博客地址 : liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"关于C语言左移和右移的一点问题","date":"2017-02-20T07:00:00.000Z","path":"2017/02/20/shift_left_right/","text":"问题在读《C语言深度解剖》一书的时候看到个关于左右移位运算的有趣的问题。问题如下： 0x01 &lt;&lt; 2+3 0x01 &lt;&lt; 2+30 0x01 &lt;&lt; 2-3 以上三个表达式运算的结果分别是多少？ 拓展思考： 左移运算的被操作数为负数或者移动负数个位应该怎么计算？ 右移运算的被操作数为负数呢？ 分析分析前先做一下 测试环境 介绍： 操作系统：Windows 7 x64 编译器：gcc version 4.8.2 (i686-posix-dwarf-rev3, Built by MinGW-W64 project) 操作系统：Mac OSX 10.11.6 编译器：Apple LLVM version 7.0.0 (clang-700.1.76) Target: x86_64-apple-darwin15.6.0 Thread model: posix 1. 先看第一个表达式 0x01 &lt;&lt; 2+3 这个其实只是运算符的优先级问题，+ 的优先级比 &lt;&lt; 运算的优先级大，所以 0x01 &lt;&lt; 2+3 等效于 0x01 &lt;&lt; (2+3) 即结果为32。 2. 第二个表达式 0x01 &lt;&lt; 2+30 这个表达式等效于 0x01 &lt;&lt; 32 ，测试代码如下： 12345678910111213141516int i = 1;int k = 0x40000000; //16进制的40000000,为2进制的 01000000...0000printf(\"0x40000000&lt;&lt;1=%d\\n\",k&lt;&lt;1);printf(\"0x40000000&lt;&lt;2=%d\\n\",k&lt;&lt;2);printf(\"0x40000000&lt;&lt;3=%d\\n\",k&lt;&lt;3);printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;32=%d\\n\",i&lt;&lt;32);printf(\"1&lt;&lt;33=%d\\n\",i&lt;&lt;33);printf(\"0x80000000&lt;&lt;1=%d\\n\",0x80000000&lt;&lt;1); //0x80000000 = -2147483648printf(\"-1&lt;&lt;1=%d\\n\",j&lt;&lt;1);printf(\"-1&lt;&lt;2=%d\\n\",j&lt;&lt;2);printf(\"-1&lt;&lt;31=%d\\n\",j&lt;&lt;31);printf(\"-1&lt;&lt;32=%d\\n\",j&lt;&lt;32);printf(\"-1&lt;&lt;33=%d\\n\",j&lt;&lt;33); 结果为： 12345678910111213140x40000000&lt;&lt;1=-21474836480x40000000&lt;&lt;2=00x40000000&lt;&lt;3=01&lt;&lt;31=-21474836481&lt;&lt;32=11&lt;&lt;33=20x80000000&lt;&lt;1=0 //即-2147483648&lt;&lt;1=0-1&lt;&lt;1=-2-1&lt;&lt;2=-4-1&lt;&lt;31=-2147483648-1&lt;&lt;32=-1-1&lt;&lt;33=-2 分析： -1的原码为 1000 0000 0000 0001-1的反码为 1111 1111 1111 1110-1的补码为 1111 1111 1111 1111左移1位后的补码 1111 1111 1111 1110左移1位后的原码 1000 0000 0000 0010 由此可见 在左移运算中，如果被操作数为有符号数，其最高位可以被覆盖 若果移动位数超过数据类型最大位数时，编译器会按移动位数对改数据类型的位数取模的结果进行移位（适用于左移和右移）。即：1&lt;&lt;32 等效于 1&lt;&lt;(32%32) = 1&lt;&lt;0 3. 对于被操作数为负数的 123456789int j = -1; printf(\"-1&gt;&gt;1=%d\\n\",j&gt;&gt;1);printf(\"-1&gt;&gt;2=%d\\n\",j&gt;&gt;2);printf(\"-1&gt;&gt;3=%d\\n\",j&gt;&gt;3);printf(\"-2&gt;&gt;1=%d\\n\",-2&gt;&gt;1);printf(\"-4&gt;&gt;1=%d\\n\",-4&gt;&gt;1);printf(\"-2&gt;&gt;2=%d\\n\",-2&gt;&gt;2);printf(\"-2&gt;&gt;3=%d\\n\",-2&gt;&gt;3); 计算结果： 1234567-1&gt;&gt;1=-1-1&gt;&gt;2=-1-1&gt;&gt;3=-1-2&gt;&gt;1=-1-4&gt;&gt;1=-2-2&gt;&gt;2=-1-2&gt;&gt;3=-1 补充知识点 逻辑左移=算数左移，右边统一添 0逻辑右移，左边统一添 0算数右移，左边添加的数和符号有关 C语言的标准指出，无符号数执行的所有移位操作都是逻辑的，而对于有符号数，采用哪种方式取决于编译器。算术左移和逻辑左移是相同的，而算术右移和逻辑右移，取决于符号位。（嵌入式移植时需要注意） 分析： -4的原码为 1000 0000 0000 0100-4的反码为 1111 1111 1111 1011-4的补码为 1111 1111 1111 1100-4左移1位后的补码 1111 1111 1111 1110-4左移1位后的原码 1000 0000 0000 0010所以在 gcc 和 clang 中应该采用的是算数右移 4. 对于第三个表达式 0x01 &lt;&lt; 2-3 测试代码 123456int i = 1;printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;-1=%d\\n\",i&lt;&lt;-1);printf(\"1&lt;&lt;-2=%d\\n\",i&lt;&lt;-2);printf(\"1&lt;&lt;-3=%d\\n\",i&lt;&lt;-3); 计算结果： 12341&lt;&lt;31=-21474836481&lt;&lt;-1=-21474836481&lt;&lt;-2=10737418241&lt;&lt;-3=536870912 分析： 对于移动位数是负数 x ，其移动位数按 x 的补码对32取余数的结果移位。 总结对于左移和右移总结如下： 1. 移动位数不能超过操作数据类型的最大位数，否则对最大位数求余后移动； 2. 如果移动位数为负数，则移动位数为负数补码对操作数据类型位数求余结果移位； 3. 对于左移，左移后的位补零，最高位符号位可以被覆盖； 4. 对于右移，正常右移分逻辑右移和算术右移，由编译器决定； 5. 对于右移，如果被操作数为负数，则将其转换成补码，然后正常右移得到原码结果。 博客地址：https://faramitaliu.github.io/","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]