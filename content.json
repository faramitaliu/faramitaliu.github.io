[{"title":"SQL必知必会(上)","date":"2017-03-01T12:00:00.000Z","path":"2017/03/01/sql_must_know_will_be/","text":"最近这段时间做了一个公司的项目，用到 SQLite3 数据库来存储数据，虽然数据并发要求不高，但存储数据量活动量有几十万（动态增删）。而且要保证机器全年正常运行。项目的有些部分数据操作实现是在应用程序部分实现，但是用 SQL 来内部实现的话效率会更高同时代码也更简洁。所以趁最近空闲一些来读下《SQL 必知必会》来补充一下欠缺。 SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写 主键（primary key）主键的作用：便于数据库的操作和管理，没有主键，更新或删除特定行就会比较困难。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每一行都必须具有一个主键值（主键列不允许NULL值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。 当多个列作为主键时，上述条件必须应用到所有列，所有列值的组合必须是唯一的（但单个列的值可以不唯一）。 SELECT语句12SELECT [DISTINCT] [column1,column2,...] [*] FROM table WHERE [关系逻辑条件] [通配符搜索 LIKE] [限制 LIMIT] [子查询] [排序 ORDER BY] ... 不是必须的情况下，尽量少使用通配符；检索不需要的列通常会降低检索和程序性能。 DISTINCT去除字段值相同的列SELECT DISTINCT column FROM … 指定从哪儿开始以及检索的行数：LIMIT num OFFSET offset_row 从 offset_row行开始检索num行（第一个被检索的行是第0行）。简化版写法：LIMIT offset_row,num （不同数据库写法有区别，此写法可用于SQLite3） 在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。DESC降序，DESC关键字只应用到直接位于其前面的列名，如果想在多个列上进行降序排序，必须对每一列指定DESC关键字。升序排列（默认）ASC。 组合WHERE子句： 逻辑操作符AND，OR（其中AND的优先级大于OR）； IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配（类似于OR）。IN取一组由逗号分隔、括在圆括号中的合法值； NOT操作符（组合其他操作符使用，否定条件）。 通配符（wildcard）：通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索。 %表示任何字符出现任意次数（0个、1个或多个，不匹配NULL）； 下划线（_），匹配单个字符。 方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。只有微软的Access和SQL Server支持集合。 说明：通配符搜索耗时，应减少使用。同时应尽量不要把它们用在搜索模式的开始处。 注释： 使用– （两个连字符）嵌在行内，– 之后的文本就是注释； 多行注释： /* 注释内容 */ ； 单行注释： #注释内容（SQLite3不支持这种注释方式）。 WHERE子句操作符（不是所有DBMS都适用） 操作符 说 明 = 等于 &lt; &gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 ! 不小于 &gt; 大于 &gt;= 大于等于 !&gt; 不大于 BETWEEN … AND … 在指定的两个值之间 IS NULL 为NULL值 计算字段拼接字段：将值联结到一起（将一个值附加到另一个值）构成单个值。Access和SQL Server使用+号。DB2、Oracle、PostgreSQL、SQLite和Open Office Base使用 || 。 1SELECT vend_name + ' (' + vend_country + ')' FROM Vendors ORDER BY vend_name; 若某个字段有空白字符，可以使用函数去除：前导空白 (LTrim)、尾随空白 (RTrim) 或前导和尾随空白 (Trim)。 对于拼接字段后新列的名字，可以使用别名（alias），用AS关键字赋予。别名还有其他用途。常见的用途包括在实际的表列名包含不合法的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 1SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')' AS vend_title FROM Vendors ORDER BY vend_name; 算术计算 直接计算使用方式： 1SELECT id,No,id*No AS new_name FROM tablename WHERE ... SQL算术操作符 操 作 符 说 明 + 加 - 减 * 乘 / 除 数值处理函数，字符串处理函数，时间日期处理函数 … SQL聚集函数：（aggregate function） 对某些行运行的函数，计算并返回一个值。 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG()函数只能作用于单个列，且计算式忽略列值为NULL的行。 COUNT()函数有两种使用方式： 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 SUM()、MAX()和MIN()函数同样忽略列值为NULL的行。 以上5个聚合函数均可如下使用： 对所有行执行计算，指定ALL参数或不指定参数（因为ALL是默认行为）。 只包含不同的值，指定DISTINCT参数。 分组数据12SELECT [column,聚合] FROM TableWHERE ... GROUP BY (分组column) HAVING ... ORDER BY ... GROUP BY 的一些规定： GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。 如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）。 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组： HAVING支持所有WHERE操作符。 HAVING 和 WHERE 的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。使用HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤。 分组和排序 ORDER BY GROUP BY 对产生的输出排序 对行分组，但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 SELECT子句顺序 子 句 说 明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 子查询123SELECT [column1,column2,...] FROM tablename WHERE condition [AND | OR] columnone [NOT]IN (SELECT columnone FROM tablename2 WHERE ... IN (SELECT...)) 使用子查询应该注意的地方： 子查询的嵌套的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。 作为子查询的SELECT语句只能查询单个列。企图检索多个列将返回错误。 作为计算字段使用子查询12345678910--需要查询Customers表中每个顾客的订单总数。订单与相应的顾客ID存储在Orders表中SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS ordersFROM Customers ORDER BY cust_name;----------------------------------------------------------------完全限定列名：用一个句点分隔表名和列名，这种语法必须在有可能混淆列名时使用，此处是2个表的cust_id比较 联结表 创建联结 在一条SELECT语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中没有指示DBMS如何对表进行联结的内容。 1234--prod_name和prod_price在一个表中，而vend_name在另一个表中。SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 注意：没有WHERE子句，第一个表中的每一行将与第二个表中的每一行配对，而不管它们逻辑上是否能配在一起。 目前为止使用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内联结（inner join）。其实，可以对这种联结使用稍微不同的语法，明确指定联结的类型。下面的SELECT语句返回与前面例子完全相同的数据： 123SELECT vend_name, prod_name, prod_priceFROM Vendors INNER JOIN Products ON Vendors.vend_id = Products.vend_id; 笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 叉联结（cross join）有时，返回笛卡儿积的联结，也称叉联结。 子查询和联接： 1234567SELECT cust_name, cust_contactFROM CustomersWHERE cust_id IN (SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = 'RGAN01')); 等效于： 12345SELECT cust_name, cust_contactFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = 'RGAN01'; 创建高级联结 迄今为止，我们使用的只是 内联结 或 等值联结 的简单联结。现在来看三种其他联结：自联结（self-join）、自然联结（natural join）和外联结（outer join）。 sqlite3 定义了三种主要类型的连接： 交叉连接 - CROSS JOIN （笛卡尔积 x*y） 内连接 - INNER JOIN (默认是内连接, inner 可以省略, 左右表都满足条件才显示) 外连接 - OUTER JOIN (sqlite3只支持 Left连接， 用右表来匹配左表，即每一行先从左表拿一条数据，再去右表找，右表没有找到，右表的项显示空，但是左表还是会显示) 自联结（self-join） 12345678910111213141516-- 子查询写法-----------------------------------------------------------SELECT cust_id, cust_name, cust_contactFROM CustomersWHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones');-- 自联结（self-join）-----------------------------------------------------------SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones';--此查询中需要的两个表实际上是相同的表，为了解决Customers的引用歧义性，使用表别名。Customers第一次出现用了别名C1，第二次出现用了别名C2。 需要注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端。 自然联结（natural join）无论何时对表进行联结，应该至少有一列不止出现在一个表中（被联结的列）。标准的联结（内联结）返回所有数据，相同的列甚至多次出现。自然联结排除多次出现，使每一列只返回一次。 自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT *），而对其他表的列使用明确的子集来完成。 123456SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = 'RGAN01'; 外联结（outer join） 1SELECT * FROM table1 [left | right | full] OUTER JOIN table2 ON conditional 全外联结（full outer join），它检索两个表中的所有行并关联那些可以关联的行。与左外联结或右外联结包含一个表的不关联的行不同，全外联结包含两个表的不关联的行。 组合查询SQL允许执行多个查询（多条SELECT语句），并将结果作为一个查询结果集返回。这些组合查询通常称为并（union） 或 复合查询（compound query）。 主要有两种情况需要使用组合查询： 在一个查询中从不同的表返回结构数据； 对一个表执行多个查询，按一个查询返回数据。 123SELECT [] FROM tablename1 WHERE conditional1UNION SELECT [] FROM tablename2 WHERE conditional2 UNION使用的规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。 其他说明 UNION从查询结果集中自动去除了重复的行；如果想返回所有的匹配行，可使用UNION ALL而不是UNION。 在用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后。 其他类型的UNION，某些DBMS还支持另外两种UNION：EXCEPT（有时称为MINUS）可用来检索只在第一个表中存在而在第二个表中不存在的行；而INTERSECT可用来检索两个表中都存在的行。 博客地址 : liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"},{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"修复sqlite3数据库","date":"2017-02-28T02:00:00.000Z","path":"2017/02/28/repair_sqlite3_db/","text":"最近碰到几次SQLite3数据库损坏的情况。现象是使用SQLite3可视化工具打开时出现密码输入框，可是SQLite3数据库在开发的时候根本没有添加加密模块，猜测可能是数据库被损坏了。因数据库里都是现场数据，需要取出分析，只能Google资料尝试恢复。 确定问题将数据库放入程序中，执行SQL操作的时候发现数据库有报错。 1malformed database schema (0)(ErrCode:11) 对于ErrCode:11。在官网可以查询到起具体含义，以及产生这种错误的可能原因： (11) SQLITE_CORRUPT The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the How To Corrupt Your Database Files for further discussion on how corruption can occur. 结合我们的实际情况猜测，机器应该是在数据库正在写入的时候突然断电或主程序被Kill导致数据写入不完整而被损坏了。 在命令行工具下，执行PRAGMA integrity_check 命令可以检测数据库完整性。 解决方法在官方提供的命令行工具下，将数据库导出为sql文件，然后新建数据库导入即可。 导出sql文件 $sqlite3 Test.db $sqlite&gt;.output tmp.sql $sqlite&gt;.dump $sqlite&gt;.quit 再导入到一个数据库中 $sqlite3 New.db $sqlite&gt;.read tmp.sql $sqlite&gt;.quit 自此，数据库已恢复完成，可以用可视化工具打开了！ 博客地址 : liuzhiqiang.tech","tags":[{"name":"SQLite3","slug":"SQLite3","permalink":"http://yoursite.com/tags/SQLite3/"},{"name":"Database","slug":"Database","permalink":"http://yoursite.com/tags/Database/"}]},{"title":"关于C语言左移和右移的一点问题","date":"2017-02-20T07:00:00.000Z","path":"2017/02/20/shift_left_right/","text":"问题在读《C语言深度解剖》一书的时候看到个关于左右移位运算的有趣的问题。问题如下： 0x01 &lt;&lt; 2+3 0x01 &lt;&lt; 2+30 0x01 &lt;&lt; 2-3 以上三个表达式运算的结果分别是多少？ 拓展思考： 左移运算的被操作数为负数或者移动负数个位应该怎么计算？ 右移运算的被操作数为负数呢？ 分析分析前先做一下 测试环境 介绍： 操作系统：Windows 7 x64 编译器：gcc version 4.8.2 (i686-posix-dwarf-rev3, Built by MinGW-W64 project) 操作系统：Mac OSX 10.11.6 编译器：Apple LLVM version 7.0.0 (clang-700.1.76) Target: x86_64-apple-darwin15.6.0 Thread model: posix 1. 先看第一个表达式 0x01 &lt;&lt; 2+3 这个其实只是运算符的优先级问题，+ 的优先级比 &lt;&lt; 运算的优先级大，所以 0x01 &lt;&lt; 2+3 等效于 0x01 &lt;&lt; (2+3) 即结果为32。 2. 第二个表达式 0x01 &lt;&lt; 2+30 这个表达式等效于 0x01 &lt;&lt; 32 ，测试代码如下： 12345678910111213141516int i = 1;int k = 0x40000000; //16进制的40000000,为2进制的 01000000...0000printf(\"0x40000000&lt;&lt;1=%d\\n\",k&lt;&lt;1);printf(\"0x40000000&lt;&lt;2=%d\\n\",k&lt;&lt;2);printf(\"0x40000000&lt;&lt;3=%d\\n\",k&lt;&lt;3);printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;32=%d\\n\",i&lt;&lt;32);printf(\"1&lt;&lt;33=%d\\n\",i&lt;&lt;33);printf(\"0x80000000&lt;&lt;1=%d\\n\",0x80000000&lt;&lt;1); //0x80000000 = -2147483648printf(\"-1&lt;&lt;1=%d\\n\",j&lt;&lt;1);printf(\"-1&lt;&lt;2=%d\\n\",j&lt;&lt;2);printf(\"-1&lt;&lt;31=%d\\n\",j&lt;&lt;31);printf(\"-1&lt;&lt;32=%d\\n\",j&lt;&lt;32);printf(\"-1&lt;&lt;33=%d\\n\",j&lt;&lt;33); 结果为： 12345678910111213140x40000000&lt;&lt;1=-21474836480x40000000&lt;&lt;2=00x40000000&lt;&lt;3=01&lt;&lt;31=-21474836481&lt;&lt;32=11&lt;&lt;33=20x80000000&lt;&lt;1=0 //即-2147483648&lt;&lt;1=0-1&lt;&lt;1=-2-1&lt;&lt;2=-4-1&lt;&lt;31=-2147483648-1&lt;&lt;32=-1-1&lt;&lt;33=-2 分析： -1的原码为 1000 0000 0000 0001-1的反码为 1111 1111 1111 1110-1的补码为 1111 1111 1111 1111左移1位后的补码 1111 1111 1111 1110左移1位后的原码 1000 0000 0000 0010 由此可见 在左移运算中，如果被操作数为有符号数，其最高位可以被覆盖 若果移动位数超过数据类型最大位数时，编译器会按移动位数对改数据类型的位数取模的结果进行移位（适用于左移和右移）。即：1&lt;&lt;32 等效于 1&lt;&lt;(32%32) = 1&lt;&lt;0 3. 对于被操作数为负数的 123456789int j = -1; printf(\"-1&gt;&gt;1=%d\\n\",j&gt;&gt;1);printf(\"-1&gt;&gt;2=%d\\n\",j&gt;&gt;2);printf(\"-1&gt;&gt;3=%d\\n\",j&gt;&gt;3);printf(\"-2&gt;&gt;1=%d\\n\",-2&gt;&gt;1);printf(\"-4&gt;&gt;1=%d\\n\",-4&gt;&gt;1);printf(\"-2&gt;&gt;2=%d\\n\",-2&gt;&gt;2);printf(\"-2&gt;&gt;3=%d\\n\",-2&gt;&gt;3); 计算结果： 1234567-1&gt;&gt;1=-1-1&gt;&gt;2=-1-1&gt;&gt;3=-1-2&gt;&gt;1=-1-4&gt;&gt;1=-2-2&gt;&gt;2=-1-2&gt;&gt;3=-1 补充知识点 逻辑左移=算数左移，右边统一添 0逻辑右移，左边统一添 0算数右移，左边添加的数和符号有关 C语言的标准指出，无符号数执行的所有移位操作都是逻辑的，而对于有符号数，采用哪种方式取决于编译器。算术左移和逻辑左移是相同的，而算术右移和逻辑右移，取决于符号位。（嵌入式移植时需要注意） 分析： -4的原码为 1000 0000 0000 0100-4的反码为 1111 1111 1111 1011-4的补码为 1111 1111 1111 1100-4左移1位后的补码 1111 1111 1111 1110-4左移1位后的原码 1000 0000 0000 0010所以在 gcc 和 clang 中应该采用的是算数右移 4. 对于第三个表达式 0x01 &lt;&lt; 2-3 测试代码 123456int i = 1;printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;-1=%d\\n\",i&lt;&lt;-1);printf(\"1&lt;&lt;-2=%d\\n\",i&lt;&lt;-2);printf(\"1&lt;&lt;-3=%d\\n\",i&lt;&lt;-3); 计算结果： 12341&lt;&lt;31=-21474836481&lt;&lt;-1=-21474836481&lt;&lt;-2=10737418241&lt;&lt;-3=536870912 分析： 对于移动位数是负数 x ，其移动位数按 x 的补码对32取余数的结果移位。 总结对于左移和右移总结如下： 1. 移动位数不能超过操作数据类型的最大位数，否则对最大位数求余后移动； 2. 如果移动位数为负数，则移动位数为负数补码对操作数据类型位数求余结果移位； 3. 对于左移，左移后的位补零，最高位符号位可以被覆盖； 4. 对于右移，正常右移分逻辑右移和算术右移，由编译器决定； 5. 对于右移，如果被操作数为负数，则将其转换成补码，然后正常右移得到原码结果。 博客地址：https://faramitaliu.github.io/","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]