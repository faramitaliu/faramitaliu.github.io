[{"title":"关于C语言左移和右移的一点问题","date":"2017-02-20T07:00:00.000Z","path":"2017/02/20/shift_left_right/","text":"问题在读《C语言深度解剖》一书的时候看到个关于左右移位运算的有趣的问题，虽然不是经常碰到，但是有必要测试一下。问题如下： 0x01 &lt;&lt; 2+3 0x01 &lt;&lt; 2+30 0x01 &lt;&lt; 2-3 以上三个表达式运算的结果分别是多少？ 拓展思考： 左移运算的被操作数为负数或者移动负数个位应该怎么计算？ 右移运算的被操作数为负数呢？ 分析分析前先做一下 测试环境 介绍： 操作系统：Windows 7 x64 编译器：gcc version 4.8.2 (i686-posix-dwarf-rev3, Built by MinGW-W64 project) 操作系统：Mac OSX 10.11.6 编译器：Apple LLVM version 7.0.0 (clang-700.1.76) Target: x86_64-apple-darwin15.6.0 Thread model: posix 1. 先看第一个表达式 0x01 &lt;&lt; 2+3 这个其实只是运算符的优先级问题，+ 的优先级比 &lt;&lt; 运算的优先级大，所以 0x01 &lt;&lt; 2+3 等效于 0x01 &lt;&lt; (2+3) 即结果为32。 2. 第二个表达式 0x01 &lt;&lt; 2+30 这个表达式等效于 0x01 &lt;&lt; 32 ，测试代码如下： 12345678910111213141516int i = 1;int k = 0x40000000; //16进制的40000000,为2进制的 01000000...0000printf(\"0x40000000&lt;&lt;1=%d\\n\",k&lt;&lt;1);printf(\"0x40000000&lt;&lt;2=%d\\n\",k&lt;&lt;2);printf(\"0x40000000&lt;&lt;3=%d\\n\",k&lt;&lt;3);printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;32=%d\\n\",i&lt;&lt;32);printf(\"1&lt;&lt;33=%d\\n\",i&lt;&lt;33);printf(\"0x80000000&lt;&lt;1=%d\\n\",0x80000000&lt;&lt;1); //0x80000000 = -2147483648printf(\"-1&lt;&lt;1=%d\\n\",j&lt;&lt;1);printf(\"-1&lt;&lt;2=%d\\n\",j&lt;&lt;2);printf(\"-1&lt;&lt;31=%d\\n\",j&lt;&lt;31);printf(\"-1&lt;&lt;32=%d\\n\",j&lt;&lt;32);printf(\"-1&lt;&lt;33=%d\\n\",j&lt;&lt;33); 结果为： 12345678910111213140x40000000&lt;&lt;1=-21474836480x40000000&lt;&lt;2=00x40000000&lt;&lt;3=01&lt;&lt;31=-21474836481&lt;&lt;32=11&lt;&lt;33=20x80000000&lt;&lt;1=0 //即-2147483648&lt;&lt;1=0-1&lt;&lt;1=-2-1&lt;&lt;2=-4-1&lt;&lt;31=-2147483648-1&lt;&lt;32=-1-1&lt;&lt;33=-2 分析： -1的原码为 1000 0000 0000 0001-1的反码为 1111 1111 1111 1110-1的补码为 1111 1111 1111 1111左移1位后的补码 1111 1111 1111 1110左移1位后的原码 1000 0000 0000 0010 由此可见 在左移运算中，如果被操作数为有符号数，其最高位可以被覆盖 若果移动位数超过数据类型最大位数时，编译器会按移动位数对改数据类型的位数取模的结果进行移位（适用于左移和右移）。即：1&lt;&lt;32 等效于 1&lt;&lt;(32%32) = 1&lt;&lt;0 3. 对于被操作数为负数的 123456789int j = -1; printf(\"-1&gt;&gt;1=%d\\n\",j&gt;&gt;1);printf(\"-1&gt;&gt;2=%d\\n\",j&gt;&gt;2);printf(\"-1&gt;&gt;3=%d\\n\",j&gt;&gt;3);printf(\"-2&gt;&gt;1=%d\\n\",-2&gt;&gt;1);printf(\"-4&gt;&gt;1=%d\\n\",-4&gt;&gt;1);printf(\"-2&gt;&gt;2=%d\\n\",-2&gt;&gt;2);printf(\"-2&gt;&gt;3=%d\\n\",-2&gt;&gt;3); 计算结果： 1234567-1&gt;&gt;1=-1-1&gt;&gt;2=-1-1&gt;&gt;3=-1-2&gt;&gt;1=-1-4&gt;&gt;1=-2-2&gt;&gt;2=-1-2&gt;&gt;3=-1 补充知识点 逻辑左移=算数左移，右边统一添 0逻辑右移，左边统一添 0算数右移，左边添加的数和符号有关 C语言的标准指出，无符号数执行的所有移位操作都是逻辑的，而对于有符号数，采用哪种方式取决于编译器。算术左移和逻辑左移是相同的，而算术右移和逻辑右移，取决于符号位。（嵌入式移植时需要注意） 分析： -4的原码为 1000 0000 0000 0100-4的反码为 1111 1111 1111 1011-4的补码为 1111 1111 1111 1100-4左移1位后的补码 1111 1111 1111 1110-4左移1位后的原码 1000 0000 0000 0010所以在 gcc 和 clang 中应该采用的是算数右移 4. 对于第三个表达式 0x01 &lt;&lt; 2-3 测试代码 123456int i = 1;printf(\"1&lt;&lt;31=%d\\n\",i&lt;&lt;31);printf(\"1&lt;&lt;-1=%d\\n\",i&lt;&lt;-1);printf(\"1&lt;&lt;-2=%d\\n\",i&lt;&lt;-2);printf(\"1&lt;&lt;-3=%d\\n\",i&lt;&lt;-3); 计算结果： 12341&lt;&lt;31=-21474836481&lt;&lt;-1=-21474836481&lt;&lt;-2=10737418241&lt;&lt;-3=536870912 分析： 对于移动位数是负数 x ，其移动位数按 x 的补码对32取余数的结果移位。 总结对于左移和右移总结如下： 1. 移动位数不能超过操作数据类型的最大位数，否则对最大位数求余后移动； 2. 如果移动位数为负数，则移动位数为负数补码对操作数据类型位数求余结果移位； 3. 对于左移，左移后的位补零，最高位符号位可以被覆盖； 4. 对于右移，正常右移分逻辑右移和算术右移，由编译器决定； 5. 对于右移，如果被操作数为负数，则将其转换成补码，然后正常右移得到原码结果。","tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Hello World","date":"2017-02-18T07:06:51.000Z","path":"2017/02/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]